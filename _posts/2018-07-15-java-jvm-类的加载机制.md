---
layout: post
title: "Java-JVM-类加载机制"
date: 2018-07-15 12:38:49
categories: java
tags: 
- java
- jvm
---
## 一、前言
　　本篇对于类加载机制将从以下几个方面展开：

* [什么是类加载机制](#什么是类加载机制)
* [类的生命周期](#类的生命周期)
* [类加载的过程](#类加载的过程)
* [类加载器](#类加载器)
<!-- more -->

## 二、背景
　　最近准备巩固已学的 Java 知识，同时《[面试为什么需要了解JVM](https://mp.weixin.qq.com/s/NsPNfNViujmjM_nzcCc0IA)》一文更加坚定了信念。

　　从《[Java - JVM内存结构 vs Java内存模型 vs Java对象模型](http://zhangyuyu.github.io/2018/07/10/Java-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-vs-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-vs-Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/)》开始，先准备对JVM相关的知识点进行回顾：

* **Java-JVM-类加载机制**（本篇）
* [Java-JVM-内存结构](http://zhangyuyu.github.io/2018/07/16/Java-JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/)
* [Java-JVM-GC算法](http://zhangyuyu.github.io/2018/07/20/Java-JVM-GC%E7%AE%97%E6%B3%95/)
* [Java-内存模型](http://zhangyuyu.github.io/2018/07/22/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/)

## <span id="什么是类加载机制">三、什么是类加载机制</span>
　　虚拟机把描述类的数据从`.class`文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java 类型，这就是虚拟机的类加载机制。类加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

　　加载.class文件的方式：

* 从本地系统中直接加载
* 通过网络下载.class文件
* 从zip，jar等归档文件中加载.class文件
* 从专有数据库中提取.class文件
* 将Java源文件动态编译为.class文件

## <span id="五、类的生命周期">四、类的生命周期</span>
　　类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。它们开始的顺序如下图所示：
![](/assets/img/java-class-lifecycle.png)

　　[类加载的过程](#类加载的过程)包括了前面五个阶段：加载、验证、准备、解析、初始化。加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。
　　`连接`包括了三个阶段：验证、准备、解析。连接指的是将java类的二进制代码合并到JVM的运行状态之中的过程。换言之，类加载的过程包含了三个部分：加载，连接（验证、准备、解析）和初始化。

**注意:**
　　这里的几个阶段是按顺序**开始**，而**不是**按顺序**进行或完成**，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。

## <span id="类加载的过程">五、类加载的过程</span>

### 1. 加载（Loading）
　　`加载`是`类加载`（Class Loading）的第一个阶段，在`加载`阶段，虚拟机需要完成以下三件事情：

* 通过一个类的全限定名来获取其定义的二进制字节流。
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
* 在java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

**注意：**

* 第1条中的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。如果输入数据不是`ClassFile`的结构，则会抛出`ClassFormatError`。

* 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

* 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

### 2. 验证（Verification）
　　`验证`，确保被加载的类的正确性。`验证`是`连接`阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。`验证`阶段大致会完成4个阶段的检验动作:

* 文件格式验证：验证字节流是否符合Class文件格式的规范。
　　例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。

* 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求。
　　例如：这个类是否有父类，除了java.lang.Object之外。

* 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
　　例如：类型转换是否是有效的。

* 符号引用验证：确保解析动作能正确执行。它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。
　　例如：符号引用的类、字段、方法的访问性是否可以被当前的类访问。

　　验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

### 3. 准备
　　准备阶段是正式_为类变量分配内存_并_设置类变量初始值_的阶段，这些内存都将在方法区中分配。

**注意：**

* 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。

* 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

>　　假设一个类变量的定义为：`public static int value = 3` 
>　　那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的`putstatic`指令是在程序编译后，存放于类构造器`<clinit>（）`方法之中的，所以把value赋值为3的动作将在**初始化阶段**才会执行。

### 4. 解析
　　解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

* 符号引用（Symbol References）
　　符号引用就是一组符号来描述目标，可以是任何字面量。符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

* 直接引用（Direct References）
　　直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局有关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那么引用的目标必定已经在内存中存在。

　　解析动作主要针对以下7类符号引用，其中后三种与java的动态语言支持息息相关：

* 类或接口
* 字段
* 类方法（静态方法）
* 接口方法
* 方法类型
* 方法句柄
* 调用点限定符

### 5. 初始化

#### 初始化
　　初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：

* 声明类变量是指定初始值。
* 使用静态代码块为类变量指定初始值。

#### 初始化的时机
　　什么情况下需要开始类加载过程的第一个阶段:"加载"。虚拟机规范中并没强行约束，这点可以交给虚拟机的的具体实现自由把握，但是对于初始化阶段虚拟机规范是严格规定了如下几种情况，如果类未初始化会对类进行初始化。

* 创建类的实例
* 访问某个类或接口的静态变量，或者对该静态变量赋值
* 调用类的静态方法
* 反射如(Class.forName("my.xyz.Test"))
* 初始化某个类的子类，则其父类也会被初始化
* 虚拟机启动时被标明为启动类的类，直接使用java.exe命令来运行某个主类

　　以上情况称为称对一个类进行“主动引用”。
　　除此种情况之外，均不会触发类的初始化，称为“被动引用”，比如：

* 子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。。对于静态字段，只有直接定义这个字段的类才会被初始化。
* 通过数组定义来引用类，不会触发类的初始化。
* 访问类的常量，不会初始化类。

## <span id="类加载器">六、类加载器</span>
### 1. 类加载器
　　虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取其定义的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块成为“类加载器”。

　　类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。

### 2. 类型
　　站在Java虚拟机的角度来讲，只存在两种不同的类加载器：

* 启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。
* 所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类`java.lang.ClassLoader`，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。

　　站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：

* 启动类加载器：`Bootstrap ClassLoader`，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。
* 扩展类加载器：`Extension ClassLoader`，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。
* 应用程序类加载器：`Application ClassLoader`，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

　　应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。这些类加载器之间的层次关系，称为类加载器的双亲委派模型。

### 3. 双亲委派模型

![](/assets/img/java-class-loader-parents-delegation-model.png)

　　双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父类加载器。注意，这里类加载器之间的父子关系一般不会以继承的关系实现，而是使用组合关系来复用父加载器的代码。

#### 3.1 工作流程
　　如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

#### 3.2 双亲委派模型意义

* 系统类防止内存中出现多份同样的字节码
* 保证Java程序安全稳定运行

#### 3.3 破坏双亲委派模型

* 第一次破坏：loadClass和 findClass
　　双亲委派模型是在JDK1.2之后引入的，而类加载器ClassLoader在 JDK1.0时代就已经存在。为了向前兼容，JDK1.2之后添加了一个新的方法findClass()。
　　因此，我们在编写自定义的加载器时候，最好重写findClass()方法。

* 第二次破坏：基础类调用用户的代码
　　在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等。
这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载。
而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下，Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。
　　这种情况下，可以使用线程上下文件类加载器（Thread Context ClassLoader），通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。

* 第三次破坏：程序动态性
　　”动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。
　　OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：
1）将java.＊开头的类委派给父类加载器加载。
2）否则，将委派列表名单内的类委派给父类加载器加载。
3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。
4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
7）否则，类加载器失败。
上面的查找顺序中，只有开头两点仍然符合双亲委派模型，其余的都是在平级的类加载器中进行的。

## 最后
　　本篇主要是从类的生命周期包含七个阶段（加载、验证、准备、解析、初始化、使用和卸载）说起，然后对于类加载的五个阶段（加载、验证、准备、解析、初始化）进行详细展开，最后了解了类加载器的相关知识。
　　下一篇将讲述《[Java-JVM-内存结构](http://zhangyuyu.github.io/2018/07/16/Java-JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/)》。

## References
* [java类的加载机制, 纯洁的微笑](http://www.ityouknow.com/jvm/2017/08/19/class-loading-principle.html)
* [【JVM】类加载机制, 风动静泉](https://www.cnblogs.com/z00377750/p/9176891.html)
* [破坏双亲委派模型](https://www.jianshu.com/p/166c5360a40b)
* [面试为什么需要了解JVM](https://mp.weixin.qq.com/s/NsPNfNViujmjM_nzcCc0IA)
